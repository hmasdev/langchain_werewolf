from typing import TypeVar, Iterable, Callable

from langchain_core.runnables import (
    Runnable,
    RunnableLambda,
    RunnablePassthrough,
)
from pydantic import (
    BaseModel,
    Field,
    SkipValidation,
    field_validator,
    ConfigDict,
)

from ..enums import ERole, ESide
from ..models.state import (
    MsgModel,
    StateModel,
    create_dict_without_state_updated,
    get_related_messsages,
)

TBaseGamePlayer = TypeVar('TBaseGamePlayer', bound='BaseGamePlayer')
_DEFAULT_FORMATTER = MsgModel.format


class GamePlayerRunnableInputModel(BaseModel):
    prompt: str | MsgModel  \
        = Field(..., title="the prompt to generate the message")
    system_prompt: str | None\
        = Field(default=None, title="the system prompt to generate the message")  # noqa


class BaseGamePlayer(BaseModel, frozen=True):
    model_config = ConfigDict(arbitrary_types_allowed=True)

    name: str = Field(..., title="the name of the player")
    role: ERole = Field(..., title="the role of the player")  # noqa
    side: ESide = Field(..., title="the side of the player")  # noqa
    victory_condition: str = Field(..., title="the victory condition of the player")  # noqa
    night_action: str | None = Field(default=None, title="the night action of the player")  # noqa
    question_to_decide_night_action: str | None = Field(default=None, title="the question to decide the night action of the player")  # noqa

    runnable: SkipValidation[Runnable[GamePlayerRunnableInputModel, str]] = Field(title="the runnable of the player")  # noqa
    output: SkipValidation[Runnable[str, None] | None] = Field(default=None, title="the output of the player")  # noqa
    formatter: Callable[[MsgModel], str] | str | None = Field(default=None, title="the formatter of the player")  # noqa

    translator: SkipValidation[Runnable[str, str]] = Field(default=RunnablePassthrough(), title="the translator of the player")  # noqa
    inv_translator: SkipValidation[Runnable[str, str]] = Field(default=RunnablePassthrough(), title="the inv_translator of the player")  # noqa

    @field_validator('output')
    @classmethod
    def _preprocess_output(
        cls,
        output: Callable[[str], None] | Runnable[str, None] | None = None,
    ) -> Runnable[str, None] | None:
        if output is not None and not isinstance(output, Runnable):
            return RunnableLambda(output)
        return output

    @field_validator('formatter')
    @classmethod
    def _validate_formatter(
        cls,
        formatter: Callable[[MsgModel], str] | str | None = None,
    ) -> Callable[[MsgModel], str] | str:
        formatter = formatter or _DEFAULT_FORMATTER
        if isinstance(formatter, str):
            try:
                # test
                formatter.format(**MsgModel(name='name', message='message').model_dump())  # noqa
            except KeyError:
                raise ValueError(
                    "The formatter should not includes anything other than "
                    + ', '.join('"{'+k+'}"' for k in MsgModel.model_fields.keys())  # noqa
                    + '. But the formatter is '
                    + f'"{formatter}".'
                )
        return formatter

    def act_in_night(
        self,
        players: Iterable[TBaseGamePlayer],
        messages: Iterable[MsgModel],
        state: StateModel,
    ) -> dict[str, object]:
        f"""Player's action in the night

        Args:
            players (Iterable[TBaseGamePlayer]): all players
            messages (Iterable[MsgModel]): all messages
            state (StateModel): the global state

        Returns:
            dict[str, object]: dict to update the state

        Note:
            the argument 'messages' should be generated by `{get_related_messsages.__name__}`
            the argument 'state' should be filtered according to the player role and side`
        """  # noqa
        # FIXME: players implement act_in_night to know anything about the game
        #        because the argument may include all players information, all messages, and the global state  # noqa
        return create_dict_without_state_updated(state)

    def receive_message(self, message: MsgModel) -> None:
        """Show the player

        Args:
            message (MsgModel): the message to show
        """
        formatter = self.formatter or _DEFAULT_FORMATTER
        if self.output:
            if isinstance(formatter, str):
                self.output.invoke(formatter.format(**message.model_dump()))  # noqa
            else:
                self.output.invoke(formatter(message))

    def generate_message(
        self,
        prompt: str | MsgModel,
        system_prompt: str | None = None,
    ) -> MsgModel:
        """Generate a message

        Args:
            prompt (str | MsgModel): the prompt to generate the message
            system_prompt (str | None, optional): the system prompt to generate the message. Defaults to None.

        Returns:
            MsgModel: the generated message
        """  # noqa
        return MsgModel(
            name=self.name,
            message=self.runnable.invoke(GamePlayerRunnableInputModel(
                prompt=prompt,
                system_prompt=system_prompt,
            ))
        )

    def ready(self) -> bool:
        """Check if the player is ready

        Returns:
            bool: True if the player is ready
        """
        return all([
            self.role is not None,
            self.side is not None,
            self.victory_condition is not None,
        ])

    @classmethod
    def instantiate(
        cls: type[TBaseGamePlayer],
        role: ERole,
        name: str,
        runnable: Runnable[GamePlayerRunnableInputModel, str],
        **kwargs,
    ) -> TBaseGamePlayer:
        """Instantiate a player

        Args:
            role (ERole): the role of the player
            name (str): the name of the player
            runnable (Runnable[GamePlayerRunnableInputModel, str]): the runnable of the player
            output (Runnable[MsgModel, None] | None, optional): the output of the player. Defaults to None.

        Returns:
            TBaseGamePlayer: the player
        """  # noqa
        from .fortune_teller import FortuneTeller
        from .knight import Knight
        from .villager import Villager
        from .werewolf import Werewolf

        rolename2roleclass_map: dict[ERole, type[TBaseGamePlayer]] = {
            ERole.FortuneTeller: FortuneTeller,  # type: ignore
            ERole.Knight: Knight,  # type: ignore
            ERole.Villager: Villager,  # type: ignore
            ERole.Werewolf: Werewolf,  # type: ignore
        }
        try:
            return rolename2roleclass_map[role](name=name, runnable=runnable, **kwargs)  # noqa
        except KeyError:
            raise ValueError(f"Unknown role: {role}. Select {list(rolename2roleclass_map.keys())}")  # noqa
